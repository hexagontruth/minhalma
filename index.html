<!DOCTYPE html>
<!--
Minhalma v0.1.0

Copyright (c) 2019, Graham Steele

Permission is hereby granted to use, copy, modify, and distribute this software for HEXAGONAL AWARENESS purposes, provided that this notice appears in all copies.

This software is provided as is, without warranty of any kind, express or implied.
-->
<html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Minhalma</title>
<meta charset="UTF-8">
<link rel='icon' type='image/svg+xml' href='data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iMTAwcHgiIGhlaWdodD0iMTAwcHgiIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBkYXRhLXdlZGdlPSJjdXJkIj4KPGc+Cjxwb2x5Z29uIGZpbGw9IiM1NkE2NDYiIHBvaW50cz0iNTAsMCAzNy42MjgsMjEuNDI5IDUwLDQyLjg1NyA2Mi4zNzIsMjEuNDI5Ii8+Cjxwb2x5Z29uIGZpbGw9IiNDQjQzMzYiIHBvaW50cz0iNTAsNTcuMTQzIDM3LjYyOCw3OC41NzEgNTAsMTAwIDYyLjM3Miw3OC41NzEiLz4KPHBvbHlnb24gZmlsbD0iI0ZGQ0QzMyIgcG9pbnRzPSI2LjY5OSwyNSAxOS4wNyw0Ni40MjkgNDMuODE0LDQ2LjQyOSAzMS40NDIsMjUiLz4KPHBvbHlnb24gZmlsbD0iIzkwNjU5RSIgcG9pbnRzPSI1Ni4xODYsNTMuNTcxIDY4LjU1OCw3NSA5My4zMDEsNzUgODAuOTMsNTMuNTcxIi8+Cjxwb2x5Z29uIGZpbGw9IiM0RDk1QzEiIHBvaW50cz0iOTMuMzAxLDI1IDY4LjU1OCwyNSA1Ni4xODYsNDYuNDI5IDgwLjkzLDQ2LjQyOSIvPgo8cG9seWdvbiBmaWxsPSIjRjU4MjMyIiBwb2ludHM9IjQzLjgxNCw1My41NzEgMTkuMDcsNTMuNTcxIDYuNjk5LDc1IDMxLjQ0Miw3NSIvPgo8L2c+Cjwvc3ZnPg=='/>
<style>
* {
  box-sizing: border-box;
  border: 0; padding: 0; margin: 0;
  transition: all 100ms;
}

html,body {
  width: 100%;
  height: 100%;
}

html {
  position: relative;
  font-family: monospace;
  font-family: 'DejaVu Sans Mono', 'Lucida Console', 'Lucida Sans Typewriter', Monaco, 'Noto Mono', monospace;
  font-size: 20px;
  background: #fffcfa;
  color: #333;
}

.status, .message {
  position: fixed;
  left: 0;
  width: 100%;
}

.status {
  top: 0;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: stretch;
  height: 1.5rem;
  padding: 1px;
}
.message, .turn {
  position: fixed;
  min-height: 2rem;
  padding: 0.25rem;
  line-height: 1.5;
}

.turn {
  top: 1.5rem;
  right: 0.5rem;
  width: 6rem;
  text-align: right;
}

.message {
  bottom: 0;
  text-align: center;
  white-space: pre-wrap;
}

.status div {
  display: flex;
  align-items: center;
  justify-content: center;
  width: calc(100% / 6);
  margin: 1px;
  cursor: pointer;
  opacity: 0.5;
}

.status div.active { opacity: 1; }

.status div.disabled {
  cursor: default;
  opacity: 0.1;
}

.status div::before {
  text-align: center;
  font-size: 0.67rem;
  font-weight: bold;
  line-height: ;
  color: #fff;
}

.status div.human::before { content: 'H'; }

svg {
  position: fixed;
  top: 0;
  left: 0;
  display: block;
  width: 100%;
  height: 100%;
  padding: 2rem 0;
}

polygon {
  fill: #bba;
  cursor: default;
  opacity: 1;
}

polygon.last-move { opacity: 0.75; }

polygon.clicked { opacity: 0.9; }

polygon.unit-human { cursor: pointer; }

polygon.highlight {
  cursor: pointer;
  opacity: 0.67;
}

.player-0 { fill: #cb4336; background-color: #cb4336; }
.player-1 { fill: #f58232; background-color: #f58232; }
.player-2 { fill: #ffcd33; background-color: #ffcd33; }
.player-3 { fill: #56a646; background-color: #56a646; }
.player-4 { fill: #4d95c1; background-color: #4d95c1; }
.player-5 { fill: #90659e; background-color: #90659e; }

/* --- RESPONSIVE CRAP --- */

@media screen and (max-width: 800px), screen and (max-height: 600px) {
  html { font-size: 16px; }
}

@media screen and (max-width: 640px), screen and (max-height: 480px) {
  html { font-size: 12px; }
}

@media screen and (max-width:  480px), screen and (max-height: 360px) {
  html { font-size: 10px; }
}
</style>
<script>
// --- GLOBALS AND CONFIG ---

const DEFAULT_SIZE = 3;
const DEFAULT_SEARCH_DEPTH = 7;
const SKIP_THRESHOLD = 1;
const LAST_UNIT_BONUS = 2

const _DISABLED = 0;
const _HUMAN = 1;
const _COMPUTER = 2;
const DEFAULT_PLAYERS = [
  _HUMAN,
  _COMPUTER,
  _COMPUTER,
  _COMPUTER,
  _COMPUTER,
  _COMPUTER
];

// --- INIT ---

document.addEventListener('DOMContentLoaded', () => {
  config = new Config();
  new Game(config).start();
});

document.addEventListener('keydown', (ev) => {
  let game = Game.instance;
  let key = ev.key.toLowerCase();
  if (key == 'n') {
    new Game(Config.instance).start();
  }
  else if (key == ' ') {
    if (game.state == 0)
      game.start();
    else if (game.isComputerTurn) 
      game.requestPause();
  }
  else if (!game.isComputerTurn || this.state != 1) {
    if (key == 's') {
      game.board.display(Locale.inProgress);
    }
    else if (key == 'r') {
      game.board.display(Locale.ranking);
    }
    else if (key == 'c') {
      game.downloadCurrent();
    }
    else if (key == 'd') {
      game.downloadHistory();
    }
    else if (key == '?' || key =='h') {
      game.board.display(Locale.help);
    }
    else if (ev.key == 'ArrowLeft') {
      Game.instance.historyTo(Game.instance.moveState - 1)
    }
    else if (ev.key == 'ArrowRight') {
      Game.instance.historyTo(Game.instance.moveState + 1)
    }
    else if (ev.key == 'PageDown' || ev.key == 'ArrowDown') {
      Game.instance.historyTo(0);
    }
    else if (ev.key == 'PageUp' || ev.key == 'ArrowUp') {
      Game.instance.historyTo();
    }
    else if (ev.key == 'u') {
      Game.instance.undo();
    }
  }
})

// --- COMPONENTS AND STUFF ---

const Locale = {
  welcome: 'Welcome to Minhalma',
  inProgress: (g) => `Game in progress with ${g.players.length} players`,
  skip: (g) => `Skipping ${g.turn} due to lack of move!`,
  victory: (g) => `${g.rank.slice(-1)[0]} comes in ${Locale.ord(g.rank.length)}!`,
  continue: 'Press &lt;space&gt; to continue or N for new game',
  final: (g) => `Final ranking: ${g.rank.map((e) => e.shortName()).join(', ')}`,
  ranking: (g) => `Current ranking: ${g.rank.map((e) => e.shortName()).join(', ')}`,
  paused: '- Game paused -',
  help: '(N)ew game (U)ndo (D)ownload history\nSee README for additional options.',
  inHistory: 'Press &lt;PgUp&gt; to return to current position',
  ord: (n) => n + (['th', 'st', 'nd', 'rd'][n] || 'th')
};

class Config {
  constructor(args) {
    Config.instance = this;
    // Map args
    let urlArgs = window.location.search.slice(1)
    .split('&').map((e) => e.split('='))
    .reduce((a, e) => {
      a[e[0]] = e[1];
      return a;
    }, {});
    args = Object.assign(urlArgs, args);

    this.depth = parseInt(args.depth) || DEFAULT_SEARCH_DEPTH;
    this.size = parseInt(args.size) || DEFAULT_SIZE;
    this.units = parseInt(args.units) || this.size * (this.size + 1) / 2;
    this.spacing = 92 / ((this.size * 3) + 1);
    this.cellRadius = this.spacing * 4 / 9;

    // Set target h and rows
    let h = 0, r = 0, i = 0;
    while(i < this.units && ++r) {
      i = i + r;
      h += r * (r - 1);
    }
    this.h = h - (i - this.units) * (r - 1);
    this.rows = r;

    // Create players
    let playerTypes = DEFAULT_PLAYERS;
    if (args.players) {
      playerTypes = args.players.split('').map((e) => parseInt(e)).slice(0, 6);
      while (playerTypes.length < 6)
        playerTypes.push(0);
    }
    this.players = playerTypes.map((e, i) => new Player(this, i, e));
  }
}

class Game {
  constructor(config, container) {
    if (Game.instance && !Game.instance.isDone)
      Game.instance.done();
    Game.instance = this;
    this.config = config;
    this.board = new Board(this, container);
    this.state = 0;
    this.moveState = 0;
    this.pauseRequested = false;
    this.moves = [];
    this.rank = [];

    this.players = config.players.filter((e) => e.type != _DISABLED);
    // Initialize units
    this.players.forEach((player, i) => {
      player.game = this;
      player.next = this.players[(i + 1) % this.players.length];
      player.prev = this.players[(this.players.length + i - 1) % this.players.length];
      // Place units
      let units = player.units.values();
      for (let i = 0; i < config.rows; i++) {
        player.origin.dirCubics(player.dir, i).forEach((e) => {
          let unit = units.next().value;
          if (unit) {
            this.board.cells[e].setUnit(unit);
            this.board.cells[e.inverse()].goalFor = player;
          }
        });
      }
    });
    this.turn = this.players[0].prev;
  }

  nextTurn() {
    if (this.state != 1) return;
    if (this.checkForCompletion()) return;
    if (this.pauseRequested) {
      this.pause();
    }
    else if (this.turn.victory) {
      this.state = 0;
      let winner = this.turn;
      this.rank.push(winner);
      this.moves.slice(-1)[0][3] = true;
      winner.prev.next = winner.next;
      winner.next.prev = winner.prev;
      this.turn = winner.prev;
      this.players = this.players.filter((e) => e != winner);
      this.board.display(
        Locale.victory,
        this.checkForCompletion() ? Locale.final : Locale.continue
      );
    }
    else {
      this.turn = this.turn.next;
      if (this.checkValidMoves()) {
        this.board.setCurrentPlayer(this.turn);
        if (this.turn.computer) {
          this.computeTurn();
        }
      }
    }
  };

  // Find at least one move for current player, otherwise skip
  // (This is borderline impossible under normal conditions)
  checkValidMoves() {
    for (let unit of this.turn.units)
      if (this.getMoves(unit.cell).length > 0) return true;
    this.pushMove();
    this.pause(Locale.skip, Locale.continue);
  }

  // We put this in a separate function for when a human player is re-assigned mid-turn
  computeTurn() {
    if (this.state == 0)
      this.unpause();
    let move = this.node(this.turn, {}, 0, 0);
    this.pushMove(move.source, move.target);
  }

  get isComputerTurn() { return this.turn.computer; }

  requestPause() {
    this.pauseRequested = true;
  }

  pause(...messages) {
    if (messages.length == 0)
      messages.push(Locale.paused);
    this.state = 0;
    this.pauseRequested = false;
    this.board.display(...messages);
  }

  unpause() {
    this.board.display(Locale.inProgress);
    this.state = 1;
  }

  start() {
    if (this.state != 0) return;
    this.unpause();
    this.nextTurn();
    this.board.turnElement.innerHTML = this.moves.length;
  }

  pushMove(source, target) {
    if (source) {
      this.moveState = this.moves.push([this.turn, source, target, false]);
      this.move(source, target, true);
    }
    else {
      this.moveState = this.moves.push([this.turn, null, null, false]);
    }
      this.board.turnElement.innerHTML = this.moves.length;
    // This fails to redraw CSS on larger boards with requestAnimationFrame
    setTimeout(() => this.nextTurn(), 100);
  }

  move(source, target, fwd) {
    target.setUnit(source.unit, fwd);
  }

  checkForCompletion() {
    if (this.players.length < 2) {
      this.done();
      return true;
    }
  }

  done() {
    this.state = -1;
    this.board.display(Locale.final);
    if (!this.isDone) {
      this.isDone = true;
      this.rank.push(this.players[0]);
      if (this.moves.length > 0)
        Game.history.push(this.moves);
    }
  }

  getMoves(cell) {
    let test = cell;
    var moves = [];
    for (let i = 0; i < 6; i++) {
      let nbr = cell.neighbors[i];
      if (!nbr) continue;
      if (!nbr.subunit) {
        moves.push(nbr);
      }
      else {
        let target = cell.jumps[i];
        if (target && !target.subunit) {
          this.pushHop(moves, cell, nbr, target);
        }
        if (nbr.goalFor == cell.subunit.player && nbr.subunit.player != cell.subunit.player) {
          moves.push(nbr);
        }
      }
    };
    return moves;
  };

  pushHop(moves, source, jumped, target) {
    if (moves.indexOf(target) != -1) return;

    // Add target to moves if not already present
    moves.push(target);
    // Iterate over target neighbors for new hops
    for (let i = 0; i < 6; i++) {
      let nbr = target.neighbors[i];
      // Skip nulls, empties, and source
      if (!nbr || !nbr.subunit || nbr == jumped || moves.indexOf(nbr) != -1) continue;
      // Check for target conditions
      var newTarget = target.jumps[i];
      if (newTarget && !newTarget.subunit)
        this.pushHop(moves, target, nbr, newTarget);
    };
  };

  undo() {
    if (this.isComputerTurn || this.state != 1) return;
    let last;
    for (let i = this.moves.length - 1; i >= 0; i--) {
      if (this.moves[i][0] == this.turn) {
        last = i;
        break;
      }
    }
    if (last != null) {
      this._historyTo(last);
      this.moves.splice(last);
      this.moveState = this.moves.length;
      this.board.turnElement.innerHTML = this.moveState;
    }
  }

  historyTo(idx) {
    // Check and fail silently when of range
    idx = idx != null ? idx : this.moves.length;
    if (idx > this.moves.length || idx < 0) return;
    this._historyTo(idx);
    // Update and display
    this.moveState = idx;
    if (this.moveState != this.moves.length) {
      this.state = 2;
      this.board.turnElement.innerHTML = idx + '/' + (this.moves.length);
      this.board.display(Locale.inHistory);
    }
    else {
      this.board.turnElement.innerHTML = idx;
      if (this.state == 2) {
        if (this.isDone) {
          this.done();
        }
        else if (this.isComputerTurn)
          this.pause();
        else
          this.unpause();
      }
    }
  }

  _historyTo(idx) {
    let cur = this.moveState;
    // Go forward
    while (cur < idx) {
      let move = this.moves[cur];
      this.move(move[1], move[2], true);
      cur ++;
    }
    // Or go backward
    while (cur > idx) {
      let move = this.moves[--cur];
      this.move(move[2], move[1], false);
    }
  }

  export(moves) {
    return moves.map((e) => [e[0].dir, e[1].cubic, e[2].cubic, e[3]]);
  }

  blobify(data, filename, indentLevels) {
    let json = JSON.stringify(data);
    // Yes we are doing this
    let level = 0;
    let str = '';
    for (let i = 0; i < json.length; i++) {
      let char = json[i];
      str += char;
      if (char == '[' && ++level <= indentLevels) {
        str += '\n' + '  '.repeat(level);
      }
      else if (char == ']' && --level <= indentLevels) {
        if (json[i + 1] == ',') {
          i ++;
          str += ',';
        }
        str += '\n' + '  '.repeat(json[i + 1] == ']' ? level - 1 : level);
      }
    }
    let blob = new Blob([str], {type: 'applicaton/json'});
    let a = this.board.createElement('a', {href: window.URL.createObjectURL(blob), download: filename});
    a.click();
  }

  downloadCurrent() {
    let currentGame = this.export(this.moves);
    this.blobify(currentGame, 'minhalma-current.json', 1);
  }

  downloadHistory() {
    let history = Game.history.map((e) => this.export(e));
    if (this.moves != Game.history.slice(-1)[0])
      history.push(this.export(this.moves));
    this.blobify(history, 'minhalma-history.json', 2);
  }

  // Recursive AI decision node
  node(player, parent, depth, n) {
    let node = {};
    node.player = player;
    node.parent = parent;
    node.set = false;
    // Check for victory condition
    if (player.h <= config.h) {
      node.h = -1e5 + depth;
    }
    // Check for max depth
    else if (depth >= this.config.depth) {
      node.h = 0;
      for (let p of this.players)
        node.h += this.turn == p ? p.h : -p.h;
    }
    // Else recursively iterate over units, moves, players
    else {
      // This is to avoid conditionally switching between < and >
      let hCoef = player == this.turn ? 1 : -1;
      node.h = 1e4 * hCoef;
      let zeta = (parent.set ? parent.h : node.h) * hCoef;

      // Iterate over units
      let bestPlayerH = player.h;
      let pruneFlag = false;
      let unit = player.unitHead;
      let units = [];
      while ((unit = unit.next) && unit.next) units.push(unit);
      for (let i = 0; i < units.length; i++) {
        let unit = units[i];
        let source = unit.cell;
        for (let target of this.getMoves(unit.cell)) {
          target.setSubunit(unit);

          // Skip if move is facially worse than given threshold
          if (player.h < bestPlayerH + SKIP_THRESHOLD) {
            // Get children
            let child = this.node(player.next, node, depth + 1, ++n);
            if (!i) child.h -= LAST_UNIT_BONUS;
            n = child.n;

            let _ch = child.h * hCoef;
            let _nh = node.h * hCoef;
            // Check if best child node
            if (_ch < _nh) {
              node.set = true;
              node.h = child.h;
              node.source = source;
              node.target = target;
            }

            if (player.h < bestPlayerH) {
              bestPlayerH = player.h;
              // Tie breaker
              if (_ch == _nh) {
                node.set = true;
                node.source = source;
                node.target = target;
              }
            }

            // Check for pruning
            if (_nh > zeta)
              pruneFlag = true;
          }
          source.setSubunit(unit);
          if (pruneFlag) break;
        }; // End of move iteration
        if (pruneFlag) break;
      }; // End of unit iteration
    } // End node if
    node.n = n; // This is presently only used for debugging
    return node;
  }
}
Game.history = [];

class Player {
  constructor(config, dir, type) {
    this.config = config;
    this.dir = dir;
    this.type = type;
    this.name = this.computer ? 'Computer' : this.human ? 'Human' : 'Disabled';
    this.lastMove = null;
    this.goal = Cubic.fromDir(dir, config.size);
    this.origin = this.goal.inverse();
    this.h = 0;
    this.units = [];
    for (let i = 0; i < config.units; i++) {
      this.units.push(new Unit(this, i));
    }
      // Pad links with dummy head and tail to simplify resorting
    this.unitHead = {h: 1e4, next: this.units[0], prev: false};
    let dumTail = {h: -1e4, prev: this.units.slice(-1)[0], next: false};
    for (let i = 0; i < config.units; i++) {
      this.units[i].prev = this.units[i - 1] || this.unitHead
      this.units[i].next = this.units[i + 1] || dumTail;
    }
  }

  get computer() { return this.type == _COMPUTER };

  get human() { return this.type == _HUMAN };

  get unitClasses() {
    return [
      'player-' + this.dir,
      this.computer ? 'unit-computer' : 'unit-human'
    ];
  }

  get victory() {
    return this.h <= this.config.h;
  };

  toString() {
    return `Player ${this.dir}`;
  }

  shortName() {
    return 'P' + this.dir;
  }
}

class Unit {
  constructor(player, i) {
    this.player = player;
    this.id = i;
    this.h = player.goal.metric(player.origin);
    player.h += this.h;
  }

  setCell(cell) {
    let player = this.player;
    this.cell = cell;
    let oldH = this.h;
    this.cubic = cell.cubic;
    this.h = player.goal.metric(this.cubic);
    let deltaH = this.h - oldH;
    player.h += deltaH;
    if (deltaH > 0) {
      let temp = this.prev;
      while (temp.h < this.h)
        temp = temp.prev;
      if (temp != this.prev) {
        this.prev.next = this.next;
        this.next.prev = this.prev;
        this.prev = temp;
        this.next = temp.next;
        temp.next.prev = this;
        temp.next = this;
      }
    }
    else if (deltaH < 0) {
      let temp = this.next;
      while (temp.h > this.h) 
        temp = temp.next;
      if (temp != this.next) {
        this.prev.next = this.next;
        this.next.prev = this.prev;
        this.next = temp;
        this.prev = temp.prev;
        temp.prev.next = this;
        temp.prev = this;
      }
    }
  }
}

class Board {
  constructor(game, container) {
    container = container || document.body;
    this.game = game;
    this.cells = {};
    this.clicked = null;
    this.targets = [];

    this.points = Array(6).fill()
    .map((e, i) => [Math.sin(Math.PI / 3 * i), Math.cos(Math.PI / 3 * i)])
    .map((p) => p.map((e) => (e * game.config.cellRadius).toFixed(4)).join(','))
    .join(' ');

    container.querySelectorAll('*').forEach((e) => e.remove());
    let svgArgs = {
      width: 86.6,
      height: 100,
      viewBox: '-43.3 -50 86.6 100',
      preserveAspectRatio: 'xMidYMid meet'
    };
    this.svg = this.createSvgElement('svg', svgArgs, container);
    this.messageElement = this.createElement(null, {class: 'message'}, container);
    this.turnElement = this.createElement(null, {class: 'turn'}, container);
    let buttonContainer = this.createElement(null, {class: 'status'}, container);
    this.playerButtons = [];
    for (let i = 0; i < 6; i++) {
      let button = this.createElement(null, {}, buttonContainer);
      button.classList.add(`player-${i}`, Board.BUTTON_CLASS_MAP[game.config.players[i].type]);
      if (game.config.players[i].type != _DISABLED)
        button.addEventListener('click', () => this.togglePlayer(i));
      this.playerButtons.push(button);
    }

    // Initialize and place cells
    let boardRadius = game.config.size * 2;
    for (var i = -boardRadius; i < boardRadius + 1; i++) {
      for (var j = -boardRadius; j < boardRadius + 1; j++) {
        let cubic = new Cubic(i, j, -i -j);
        if (this._onBoard(cubic))
          this._createCell(cubic);
      }
    }

    // Set cell neighbors and jumps
    for (let cell of Object.values(this.cells)) {
      cell.neighbors = cell.cubic.neighborCubics().map((e) => this.cells[e]);
    }
    for (let cell of Object.values(this.cells)) {
      cell.jumps = cell.neighbors.map((e, i) => e ? e.neighbors[i] : null);
    }

    this.display(Locale.welcome)
  }

  togglePlayer(idx) {
    let player = this.game.config.players[idx];
    let old = player.type;
    let next = player.type = +!(old - 1) + 1; // lol
    let oldClass = Board.BUTTON_CLASS_MAP[old];
    let nextClass = Board.BUTTON_CLASS_MAP[next];
    this.playerButtons[idx].classList.remove(oldClass);
    this.playerButtons[idx].classList.add(nextClass);
    if (this.game.turn == player && next == _COMPUTER && this.game.state != -1) {
      this.game.computeTurn();
    }
  }

  // User click
  click(cell) {
    // Do nothing if game paused, over, or on non-human turn
    if (this.game.state != 1 || this.game.isComputerTurn) return;

    // Move unit if valid target
    if (this.clicked && this.targets.indexOf(cell) != -1) {
      this.game.pushMove(this.clicked, cell);
    }

    // Clear clicked state regardless of whether unit moved or not
    if (this.clicked) {
      this.clicked.elem.classList.remove('clicked');
      this.clicked = null;
      this.setTargets();
      if (cell.unit && cell != this.clicked) {
        // Move unit
      }
    }
    // Otheriwse handle initial click
    else if (!this.clicked && cell.unit && cell.unit.player == this.game.turn) {
      this.setTargets(cell);
      this.clicked = cell;
      cell.elem.classList.add('clicked');
    }
  };

  // Highlight moves
  setTargets(cell) {
    if (!cell) {
      // De-highlight all
      this.targets = [];
      for (let cell of Object.values(this.cells)) {
        if (cell) cell.setHighlight(false);
      }
    }
    else {
      // Highlight moves
      this.targets = [];
      var moves = this.game.getMoves(cell);
      this.targets = moves;
      moves.forEach(function(e) {
        e.setHighlight(true);
      });
    }
  };

  display(...messages) {
    messages = messages.map((e) => typeof e == 'function' ? e(this.game) : e);
    this.messageElement.innerHTML = messages.join('\n');
  }

  setCurrentPlayer(player) {
    this.playerButtons.forEach((e) => e.classList.remove('active'));
    this.playerButtons[player.dir].classList.add('active');
  }

  // "Cut out" hexagram by rejecting cubics with more than 2 coords > config.size
  _onBoard(cubic) {
    return cubic.reduce((a, e) => a + (Math.abs(e) > this.game.config.size), 0) < 2;
  }

  _createCell(cubic) {
    let cell = new Cell(cubic);
    this.cells[cubic] = cell;

    let xFactor = this.game.config.spacing * Math.sqrt(3) / 4;
    let yFactor = this.game.config.spacing  * 0.75
    let element = cell.elem = this._createCellElement([
      xFactor * (cubic[1] - cubic[2]),
      yFactor * -cubic[0]
    ]);
    element.cell = cell;
    element.id = 'cell_' + cubic.join('_');
    let title = this.createSvgElement('title', {}, element);
    title.innerHTML = cubic;
    element.addEventListener('click', () => this.click(cell));
  }

  createElement(tag, attribs, parent) {
    let element = document.createElement(tag || 'div');
    this._configureElement(element, attribs, parent);
    return element;
  }

  createSvgElement(tag, attribs, parent) {
    let element = document.createElementNS('http://www.w3.org/2000/svg', tag);
    this._configureElement(element, attribs, parent);
    return element;
  }

  _configureElement(element, attribs, parent) {
    attribs = attribs || {};
    for (let [k, v] of Object.entries(attribs)) {
      element.setAttribute(k, v);
    }
    if (parent) parent.appendChild(element);
  }

  _createCellElement(position) {
    let transform = `translate(${position.join(',')})`;
    let poly = this.createSvgElement('polygon', {transform, points: this.points}, this.svg);
    return poly;
  }
}
Board.BUTTON_CLASS_MAP = [
  'disabled',
  'human',
  'computer'
];

// Cubic (coordinates)

class Cubic extends Array {
  static fromDir(dir, metric) {
    return new Cubic(...Cubic.DIR_TO_CUBIC[dir]).mult(metric * 2);
  }
  static dirTuple(dir) {
    return [dir  % 3, (dir % 2) * -2 + 1];
  }

  constructor(u, v, w) {
    super();
    u = u != null ? u : -v - w;
    v = v != null ? v : -w - u;
    w = w != null ? w : -u - v;
    this.push(u);
    this.push(v);
    this.push(w);
  }

  dirCubics(dir, steps) {
    let [d, s] = Cubic.dirTuple(dir);
    let a = (d + 1) % 3;
    let b = (d + 2) % 3;
    let D = this[d] + steps * s;
    let results = [];
    for (let i = 0; i <= steps; i++) {
      let coords = new Array(3);
      coords[d] = D;
      coords[a] = this[a] - i * s;
      coords[b] = this[b] - (steps - i) * s;
      results.push(new Cubic(...coords));
    }
    return results;
  }

  neighborCubics() {
    return Cubic.NEIGHBOR_OFFSETS.map((e) => this.add(new Cubic(...e)));
  }

  add(cubic) { return new Cubic(...this.map((e, i) => e + cubic[i])); }

  mult(scalar) { return new Cubic(...this.map((e) => e * scalar)); }

  map(f) { return new Cubic(...super.map(f)); }

  inverse() { return this.map((e) => -e); }

  metric(cubic) {
    return (
      Math.abs(this[0] - cubic[0]) + Math.abs(this[1] - cubic[1]) + Math.abs(this[2] - cubic[2])
    ) / 2;
  }

  toString() { return `(${this.join(',')})`; }
}
Cubic.NEIGHBOR_OFFSETS = [
  [0, 1, -1],
  [1, 0, -1],
  [1, -1, 0],
  [0, -1, 1],
  [-1, 0, 1],
  [-1, 1, 0]
];
Cubic.DIR_TO_CUBIC = [
  [1, -0.5, -0.5],
  [0.5, -1, 0.5],
  [-0.5, -0.5, 1],
  [-1, 0.5, 0.5],
  [-0.5, 1, -0.5],
  [0.5, 0.5, -1]
];

// Cell

class Cell  {
  constructor(cubic) {
    this.cubic = cubic
    this.unit = null;
    this.subunit = null;
    this.goalFor = null;
    this.highlight = false;
  }

  setUnit(unit, fwd) {
    let otherCell = unit.cell;
    let otherUnit = this.unit;
    if (otherCell) {
      otherCell.elem.setAttribute('class', '');
      if (otherUnit) {
        otherUnit.cell.elem.setAttribute('class', '');
        otherCell.elem.classList.add(...otherUnit.player.unitClasses);
        otherCell.unit = otherUnit;
        otherCell.subunit = otherUnit;
        this.subunit.setCell(otherCell);
      }
      else {
        otherCell.unit = null;
        otherCell.subunit = null;
      }
    }
    this.unit = unit;
    this.subunit = unit;
    unit.setCell(this);
    this.elem.classList.add(...unit.player.unitClasses);
    if (fwd) {
      unit.player.units.forEach((e) => e.cell.elem.classList.remove('last-move'));
      this.elem.classList.add('last-move');
    }
  }

  setSubunit(unit) {
    if (this.subunit) {
      unit.cell.subunit = this.subunit;
      this.subunit.setCell(unit.cell);
    }
    else {
      unit.cell.subunit = null;
    }
    this.subunit = unit;
    unit.setCell(this);
  };

  setHighlight(val) {
    this.highlight = val;
    if (val)
      this.elem.classList.add('highlight');
    else
      this.elem.classList.remove('highlight');
  };

  toString() {
    var player = this.unit ? this.unit.player.name : 'none';
    return this.cubic.toString() + player;
  };
}
</script>
</head>
<body></body>
</html>