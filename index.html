<!DOCTYPE html>
<!--
Minhalma v0.4.1

Copyright (c) 2019, Graham Steele

Permission is hereby granted to use, copy, modify, and distribute this software for HEXAGONAL AWARENESS purposes, provided that this notice appears in all copies.

This software is provided as is, without warranty of any kind, express or implied.
-->
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,maximum-scale=1,minimum-scale=1"/>
<title>Minhalma</title>
<link rel='icon' type='image/svg+xml' href='data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iMTAwcHgiIGhlaWdodD0iMTAwcHgiIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBkYXRhLXdlZGdlPSJjdXJkIj4KPGc+Cjxwb2x5Z29uIGZpbGw9IiM1NkE2NDYiIHBvaW50cz0iNTAsMCAzNy42MjgsMjEuNDI5IDUwLDQyLjg1NyA2Mi4zNzIsMjEuNDI5Ii8+Cjxwb2x5Z29uIGZpbGw9IiNDQjQzMzYiIHBvaW50cz0iNTAsNTcuMTQzIDM3LjYyOCw3OC41NzEgNTAsMTAwIDYyLjM3Miw3OC41NzEiLz4KPHBvbHlnb24gZmlsbD0iI0ZGQ0QzMyIgcG9pbnRzPSI2LjY5OSwyNSAxOS4wNyw0Ni40MjkgNDMuODE0LDQ2LjQyOSAzMS40NDIsMjUiLz4KPHBvbHlnb24gZmlsbD0iIzkwNjU5RSIgcG9pbnRzPSI1Ni4xODYsNTMuNTcxIDY4LjU1OCw3NSA5My4zMDEsNzUgODAuOTMsNTMuNTcxIi8+Cjxwb2x5Z29uIGZpbGw9IiM0RDk1QzEiIHBvaW50cz0iOTMuMzAxLDI1IDY4LjU1OCwyNSA1Ni4xODYsNDYuNDI5IDgwLjkzLDQ2LjQyOSIvPgo8cG9seWdvbiBmaWxsPSIjRjU4MjMyIiBwb2ludHM9IjQzLjgxNCw1My41NzEgMTkuMDcsNTMuNTcxIDYuNjk5LDc1IDMxLjQ0Miw3NSIvPgo8L2c+Cjwvc3ZnPg=='/>
<style>
* {
  box-sizing: border-box;
  border: 0; padding: 0; margin: 0;
  transition: all 100ms;
}

html,body {
  width: 100%;
  height: 100%;
}

html {
  position: relative;
  font-family: 'DejaVu Sans Mono', 'Lucida Console', 'Lucida Sans Typewriter', Monaco, 'Noto Mono', monospace;
  font-size: 20px;
  background: #fffcfa;
  color: #333;
}

.hidden { display: none; }

.status, .message {
  position: fixed;
  left: 0;
  width: 100%;
}

.status {
  top: 0;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: stretch;
  height: 30px;
  padding: 1px;
}

.help, .turn {
  position: fixed;
  top: 30px;
  line-height: 3rem;
}

.help {
  left: 1rem;
  width: 2rem;
  cursor: pointer;
  text-align: left;
  font-size: 2rem;
}

.help:hover {
  color: rgba(51, 51, 51, 0.75);
}

.help::before {
  content: '+';
}

.turn {
  right: 1rem;
  width: 7.5rem;
  font-size: 1.5rem;
  text-align: right;
}

.message {
  position: fixed;
  bottom: 0;
  padding: 0.25rem;
  line-height: 1.5;
  text-align: center;
  white-space: pre-wrap;
}

.status div {
  display: flex;
  align-items: center;
  justify-content: center;
  width: calc(100% / 6);
  margin: 1px;
  cursor: pointer;
  opacity: 0.75;
}

.status div.disabled {
  opacity: 0.25;
  cursor: default;
}

.status div.active { opacity: 1; }

.status div::before {
  text-align: center;
  font-size: 0.67rem;
  font-weight: normal;
  line-height: 1;
  color: #fff;
}

.status div.active:before { font-weight: bold; }
.human::before { content: 'H'; }
.computer::before { content: 'C'; }

svg.board {
  position: fixed;
  top: 0;
  left: 0;
  display: block;
  width: 100%;
  height: 100%;
  padding: 40px 0;
}

svg.paused, svg.paused * {
  cursor: default !important;
}

.board polygon {
  fill: #bba;
  cursor: default;
  opacity: 1;
}

.board polygon.last-move { opacity: 0.8; }

.board polygon.clicked { opacity: 0.9; }

.board polygon.unit-human { cursor: pointer; }

.board polygon.highlight {
  cursor: pointer;
  opacity: 0.6;
}

.modal.outer {
  z-index: -10;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0;
  padding: 2rem;
  background: rgba(1,1,1,0.5);
}

.modal.outer.show {
  z-index: 10;
  opacity: 1;
}

.modal.inner {
  position: relative;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: stretch;
  width: 100%;
  max-height: 100%;
  max-width: 24rem;
  padding: 1rem 2rem 2rem 2rem;
  border-radius: 1rem;
  line-height: 1.33;
  background: #fff;
}

.close-box {
  position: absolute;
  left: 1rem;
  top: 1rem;
  width: 1.5rem;
  height: 1.5rem;
  cursor: pointer;
}

label, .group {
  flex: 0 1;
  display: block;
  line-height: 1.5rem;
  text-align: center;
}

.group {
  width: 100%;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: stretch;
  margin: calc(0.75rem - 1px) 1px;
}

.group div, button {
  position: relative;
  width: 100%;
  margin: 1px;
  background: #666;
  color: #fff;
  cursor: pointer;
}

.group div:hover, button:hover { opacity: 0.8; }

.group div:active, button:active { opacity: 0.6; }

.group div.selected { background: #999; }

.group.size div span, .group div::before {
  position: absolute;
  display: block;
  width: 100%;
  margin-top: 50%;
  transform: translateY(-50%);
  text-align: center;
  font-size: 1.25rem;
}

.group div::after {
  content: ' ';
  display: block;
  width: 100%;
  padding: 0 0 100% 0;
}

.group div.disabled { opacity: 0.4; }

button {
  padding: 0.5rem;
  font-family: inherit;
  font-size: inherit;
}

.helptext {
  flex: 0 2;
  margin: 0;
  overflow-y: auto;
}

table {
  width: 100%;
  border-collapse: collapse;
}

td {
  padding: 0;
  line-height: 1.5;
  text-align: left;
  font-family: inherit;
  font-weight: normal;
}

tr:nth-child(1) td {
  font-weight: bold;
  padding-bottom: 0.5rem;
}

td:not(:nth-child(1)) {
  font-weight: bold;
  text-align: center;
  vertical-align: middle;
}

td .icon {
  display: block;
  width: 1.5em;
  height: 1.5em;
  margin: 0 auto;
  padding: 0.25em;
  fill: #333;
}

/* --- RESPONSIVE CRAP --- */

@media screen and (max-width: 800px), screen and (max-height: 480px) {
  html { font-size: 18px; }
}

@media screen and (max-width: 640px), screen and (max-height: 360px) {
  html { font-size: 16px; }
}

@media screen and (max-width: 480px), screen and (max-height: 240px) {
  html { font-size: 14px; }
}

/* --- PLAYER COLORS --- */

.player-0 { fill: #cb4336 !important; background-color: #cb4336 !important; }
.player-1 { fill: #f58232 !important; background-color: #f58232 !important; }
.player-2 { fill: #ffcd33 !important; background-color: #ffcd33 !important; }
.player-3 { fill: #56a646 !important; background-color: #56a646 !important; }
.player-4 { fill: #4d95c1 !important; background-color: #4d95c1 !important; }
.player-5 { fill: #90659e !important; background-color: #90659e !important; }

</style>
<script>
// --- GLOBALS AND CONFIG ---

const DEFAULT_SIZE = 3;
const DEFAULT_SEARCH_DEPTH = 6;
const DEFAULT_SKIP_THRESHOLD = 1;
const DEFAULT_LAST_UNIT_BONUS = 2;

// These values are used in AI arithmetic - see reduceNodeH()
const _DISABLED = 0;
const _COMPUTER = 1;
const _HUMAN = 2;
const DEFAULT_PLAYERS = [
  _HUMAN,
  _COMPUTER,
  _COMPUTER,
  _COMPUTER,
  _COMPUTER,
  _COMPUTER
];

let HELPTEXT;

// --- INIT ---

document.addEventListener('DOMContentLoaded', () => {
  HELPTEXT = document.querySelector('#helptext').innerHTML;
  new Config();
  Game.new();
});

// --- COMPONENTS AND STUFF ---

const Locale = {
  inProgress: (g) => `Game in progress with ${g.players.length} players`,
  skip: (g) => `Skipping ${g.turn} due to lack of move`,
  victory: (g) => `${g.rank.slice(-1)[0]} comes in ${Locale.ord(g.rank.length)}!`,
  continue: 'Click or <space> to continue',
  final: (g) => `Final ranking: ${g.rank.concat(g.players).map((e) => e.shortName).join(', ')}`,
  ranking: (g) => `Current ranking: ${g.rank.map((e) => e.shortName).join(', ')}`,
  paused: '- Game paused -',
  inHistory: '<ArrowUp> to return to current position',
  debug: () => `Debugging mode ${Game.DEBUG ? 'enabled' : 'disabled'}`,
  ord: (n) => n + (['th', 'st', 'nd', 'rd'][n] || 'th')
};

class Config {
  constructor(args) {
    let oldArgs = Config.instance ? Config.instance.args : Config.defaults;
    Config.instance = this;

    // Map args
    let urlArgs = window.location.search == '' ? {} : window.location.search.slice(1)
    .split('&').map((e) => e.split('='))
    .reduce((a, e) => {
      a[e[0]] = e[0] == 'players' ? e[1].slice(0, 6).padEnd(6, '0') : parseInt(e[1]);
      return a;
    }, {});

    this.args = Object.assign({}, Config.defaults, urlArgs, args);
    this.depth = this.args.depth;
    this.size = this.args.size;
    this.units = this.args.units || this.size * (this.size + 1) / 2;
    this.spacing = 92 / ((this.size * 3) + 1);
    this.cellRadius = this.spacing * 4 / 9;
    this.skip = this.args.skip;
    this.bonus = this.args.bonus;

    // Set target h and rows
    let h = 0, r = 0, i = 0;
    while(i < this.units && ++r) {
      i = i + r;
      h += r * (r - 1);
    }
    this.h = h - (i - this.units) * (r - 1);
    this.rows = r;

    // Create players
    this.players = this.args.players.split('').map((e, i) => new Player(this, i, parseInt(e)));
    if (!Object.entries(oldArgs).every((e) => this.args[e[0]] == e[1])) {
      this._pushUrl();
    }
  }

  _pushUrl(args) {
    args = args || this.args
    let query = Object.entries(args).filter((e) => Config.defaults[e[0]] != e[1]).map((e) => e.join('=')).join('&');
    let url = window.location.href.split('?')[0];
    if (query.length > 0) url += '?' + query;
    history.pushState('ohai', document.title, url);
  }
}
Config.defaults = {
  size: DEFAULT_SIZE,
  players: DEFAULT_PLAYERS.join(''),
  depth: DEFAULT_SEARCH_DEPTH,
  skip: DEFAULT_SKIP_THRESHOLD,
  bonus: DEFAULT_LAST_UNIT_BONUS
};

class Game {
  static new() {
    let game = new Game(Config.instance);
    game.start();
    return game;
  }

  constructor(config) {
    if (Game.instance && !Game.instance.isDone)
      Game.instance.done();
    Game.instance = this;
    this.config = config;
    this.board = new Board(this);
    this.state = 0;
    this.moveState = 0;
    this.pauseRequested = false;
    this.moves = [];
    this.rank = [];
    this.nodes = [];
    this.hooks = {
      onMoveNode: []
    };

    this.players = config.players.filter((e) => e.type != _DISABLED);
    // Initialize units
    this.players.forEach((player, i) => {
      player.game = this;
      player.next = this.players[(i + 1) % this.players.length];
      player.prev = this.players[(this.players.length + i - 1) % this.players.length];
      // Place units
      let units = player.units.values();
      for (let i = 0; i < config.rows; i++) {
        player.origin.dirCubics(player.dir, i).forEach((e) => {
          let unit = units.next().value;
          if (unit) {
            this.board.cells[e].setUnit(unit);
            this.board.cells[e.inverse()].goalFor = player;
          }
        });
      }
    });
    this.turn = this.players[0].prev;
  }

  nextTurn() {
    if (this.state != 1) return;
    if (this.checkForCompletion()) return;
    if (this.pauseRequested) {
      this.pause();
    }
    else if (this.turn.victory) {
      this.turn = this.turn.prev;
      this.pause(
        Locale.victory,
        this.checkForCompletion() ? Locale.final : Locale.continue
      );
    }
    else {
      this.turn = this.turn.next;
      if (this.checkValidMoves()) {
        this.board.setCurrentPlayer(this.turn);
        if (this.turn.computer) {
          this.computeMove();
        }
      }
    }
  };

  // Find at least one move for current player, otherwise skip
  // (This is borderline impossible under normal conditions)
  checkValidMoves() {
    for (let unit of this.turn.units)
      if (this.getMoves(unit.cell).length > 0) return true;
    this.pushMove();
    this.pause(Locale.skip, Locale.continue);
  }

  // We put this in a separate function for when a human player is re-assigned mid-turn
  computeMove() {
    if (this.state == 0)
      this.unpause();
    let node = this.node(this.turn, {}, 0, 0);
    if (Game.DEBUG)
      this.pushNode(node);
    this.pushMove(node.move);
  }

  get isComputerTurn() { return this.turn.computer; }

  requestPause() {
    this.pauseRequested = true;
  }

  pause(...messages) {
    if (messages.length == 0)
      messages.push(Locale.paused);
    this.state = 0;
    this.pauseRequested = false;
    this.board.display(...messages);
    this.board.svg.classList.add('paused');
  }

  unpause() {
    this.board.display(Locale.inProgress);
    this.state = 1;
    this.board.svg.classList.remove('paused');
  }

  start() {
    if (this.state != 0) return;
    this.unpause();
    this.nextTurn();
    this.board.turnElement.innerHTML = this.moves.length;
  }

  pushNode(node) {
    this.nodes.push(node);
    for (let cb of this.hooks.onMoveNode)
      cb(node);
  }

  pushMove(move) {
    move = move || {};
    move.player = move.player || this.turn;
    move.win = move.win || false;
    if (move.source) {
      this.moveState = this.moves.push(move);
      this.moveUnit(move.source, move.target, true);
      if (this.turn.victory) move.win = true;
    }
    else {
      this.moveState = this.moves.push(move);
    }
    this.board.turnElement.innerHTML = this.moves.length;
    // This fails to redraw CSS on larger boards with requestAnimationFrame
    setTimeout(() => this.nextTurn(), 100);
  }

  moveUnit(source, target, fwd) {
    if (!source) return; // Reversing through a skip
    let player = source.unit.player;
    let swapee = target.unit && target.unit.player;
    let swapeeVictoryPrev = swapee && swapee.victory;
    if (!fwd && player.victory) // Reversing through a victory
      this.rankPlayer(player, false);
    target.setUnit(source.unit, fwd);
    if (player.victory)
      this.rankPlayer(player, true);
    // We need to check if a swapping move caused the swapee to achieve victory
    if (swapee && !swapeeVictoryPrev && swapee.victory)
      this.rankPlayer(swapee, true);
    else if (swapeeVictoryPrev && !swapee.victory)
      this.rankPlayer(swapee, false);
  }

  rankPlayer(player, fwd) {
    if (fwd) {
      this.rank.push(player);
      this.players = this.players.filter((e) => e != player);
      player.prev.next = player.next;
      player.next.prev = player.prev;
    }
    else {
      this.rank = this.rank.filter((e) => e != player);
      this.players.push(player);
      this.players.sort((a, b) => a.dir - b.dir);
      // This needs to be this elaborate because of the possibility of two victory transitions during a swap move
      let playerIdx = this.players.indexOf(player);
      let prev = this.players[(playerIdx + this.players.length - 1) % this.players.length];
      let next = this.players[(playerIdx + 1) % this.players.length];
      player.prev = prev;
      player.next = next;
      prev.next = player;
      next.prev = player;
    }
  }

  checkForCompletion() {
    if (this.players.length < 2) {
      this.done();
      return true;
    }
  }

  done() {
    this.state = -1;
    this.board.display(Locale.final);
    if (!this.isDone) {
      this.isDone = true;
      if (this.moves.length > 0) {
        Game.history.push(this.moves);
        if (Game.DEBUG) Game.nodeHistory.push(this.nodes);
      }
    }
  }

  getMoves(cell) {
    var moves = [];
    for (let i = 0; i < 6; i++) {
      let nbr = cell.neighbors[i];
      if (!nbr) continue;
      if (!nbr.subunit) {
        moves.push(nbr);
      }
      else {
        let player = cell.subunit.player;
        if (nbr.goalFor == player && nbr.subunit.player != player && !nbr.subunit.player.victory) {
          moves.push(nbr);
        }
        let target = cell.jumps[i];
        if (target && !target.subunit) {
          this.pushHop(moves, cell, nbr, target);
        }
      }
    };
    return moves;
  };

  pushHop(moves, source, jumped, target) {
    if (moves.indexOf(target) != -1) return;

    // Add target to moves if not already present
    moves.push(target);
    // Iterate over target neighbors for new hops
    for (let i = 0; i < 6; i++) {
      let nbr = target.neighbors[i];
      // Skip nulls, empties, and source
      if (!nbr || !nbr.subunit || nbr == jumped || moves.indexOf(nbr) != -1) continue;
      // Check for target conditions
      var newTarget = target.jumps[i];
      if (newTarget && !newTarget.subunit)
        this.pushHop(moves, target, nbr, newTarget);
    };
  };

  undo() {
    if (this.isComputerTurn || this.state != 1) return;
    let last;
    for (let i = this.moves.length - 1; i >= 0; i--) {
      if (this.moves[i].player == this.turn) {
        last = i;
        break;
      }
    }
    if (last != null) {
      this._historyTo(last);
      let removed = this.moves.splice(last);
      for (let move of removed) {
        // We need to account for debugging being turned off and on arbitrarily
        let nodeIdx = this.nodes.findIndex((e) => e.move == move);
        if (nodeIdx != -1) this.nodes.splice(nodeIdx, 1);
      }
      this.moveState = this.moves.length;
      this.board.turnElement.innerHTML = this.moveState;
    }
  }

  historyTo(idx) {
    // Check and fail silently when of range
    idx = idx != null ? idx : this.moves.length;
    if (idx > this.moves.length || idx < 0) return;
    this._historyTo(idx);
    // Update and display
    this.moveState = idx;
    if (this.moveState != this.moves.length) {
      this.state = 2;
      this.board.turnElement.innerHTML = idx + '/' + (this.moves.length);
      this.board.display(Locale.inHistory);
    }
    else {
      this.board.turnElement.innerHTML = idx;
      if (this.state == 2) {
        if (this.isDone) {
          this.done();
        }
        else if (this.isComputerTurn)
          this.pause();
        else
          this.unpause();
      }
    }
  }

  _historyTo(idx) {
    let cur = this.moveState;
    // Go forward
    while (cur < idx) {
      let move = this.moves[cur];
      this.moveUnit(move.source, move.target, true);
      cur ++;
    }
    // Or go backward
    while (cur > idx) {
      let move = this.moves[--cur];
      this.moveUnit(move.target, move.source, false);
    }
  }

  exportMoves(moves) {
    return moves.map((e) => [e.player.dir, e.source.cubic, e.target.cubic, e.win]);
  }

  blobify(data, filename, indent) {
    indent = indent || 2;
    let json = JSON.stringify(data);
    let level = 0;
    let str = '';
    for (let i = 0; i < json.length; i++) {
      let char = json[i];
      let next = json[i + 1];
      str += char;
      if (char == '[' && ++level <= indent && next != ']') {
        str += '\n' + '  '.repeat(level);
      }
      else if (char == ']' && --level <= indent) {
        if (next == ',') {
          i ++;
          str += ',';
        }
        str += '\n' + '  '.repeat(next == ']' ? level - 1 : level);
      }
    }
    let blob = new Blob([str], {type: 'applicaton/json'});
    let a = this.board.createElement('a', {href: window.URL.createObjectURL(blob), download: filename});
    a.click();
  }

  downloadCurrent() {
    let currentGame = this.exportMoves(this.moves);
    this.blobify(currentGame, 'minhalma-current.json', 1);
  }

  downloadHistory() {
    let history = Game.history.map((e) => this.exportMoves(e));
    if (this.moves.length > 0 && this.moves != Game.history.slice(-1)[0]) {
      history.push(this.exportMoves(this.moves));
    }
    this.blobify(history, 'minhalma-history.json', 2);
  }

  // Recursive AI decision node
  node(player, parent, depth, n) {
    // Else construct node and iterate over units, moves, players
    let node = {
      player,
      parent,
      n,
      moves: [],
      move: null,
      h: null,
      rh: Infinity,
      win: false,
      leaf: depth >= this.config.depth
    };
    // Continue to next player if player has already win
    if (player.h <= this.config.h && !node.leaf) {
      return this.node(player.next, parent, depth + 1, ++n);
    }

    let zeta = parent.h ? this._reduceNodeH(parent.h, player) : -Infinity;

    // Determine h deltas for moves
    let bestDelta = Infinity;
    let bestBonusDelta = Infinity;
    let maxUnitH = player.unitHead.next.h;
    let moveCount = 0;
    let moveMap = [];
    for (let unit of player.units) {
      let bonusCoef = unit.h == maxUnitH ? this.config.bonus : 1;
      let source = unit.cell;
      for (let target of this.getMoves(source)) {
        moveCount++;
        let delta = target.cubic.metric(player.goal) - unit.h;
        let radialDelta = target.cubic.metricFromOrigin() - source.cubic.metricFromOrigin();
        let bonusDelta = delta * bonusCoef;
        if (delta < bestDelta) bestDelta = delta;
        if (bonusDelta < bestBonusDelta) bestBonusDelta = bonusDelta;
        if (!moveMap[bonusDelta]) moveMap[bonusDelta] = [];
        moveMap[bonusDelta].push({delta, radialDelta, bonusDelta, source, target});
      }
    }
    // If there are no generated moves, skip to next player at same depth
    if (moveCount == 0)
      return this.node(player.next, parent, depth, ++node.n);
    // Or if at max depth, set h assuming best move delta or victory (we don't need to find actual move)
    else if (node.leaf) {
      node.h = [0, 0, 0, 0, 0, 0];
      for (let p of this.players)
        node.h[p.dir] = p.h;
      if (player.h > this.config.h)
        node.h[player.dir] += bestDelta;
      else
        node.win = true;
    }
    // Or fully iterate over moves below qualifying threshold
    else {
      let threshold = bestBonusDelta + (this.moves.length < this.players.length ? 0 : this.config.skip);
      for (let i = bestBonusDelta; i <= threshold && node.moves.length < this.config.units; i++) {
        if (moveMap[i]) {
          node.moves = node.moves.concat(moveMap[i]);
        }
      }
      for (let move of node.moves) {
        let unit = move.source.subunit;
        move.target.setSubunit(unit);
        // Get child node
        let child = this.node(player.next, node, depth + 1, ++node.n);
        node.n = child.n;
        // If current move is player victory, set low-but-precise h value, prioritizing lower depth states
        if (player.h <= this.config.h) {
          node.win = true;
          child.h[player.dir] = -1e3 + depth;
        }
        let childRh = this._reduceNodeH(child.h, player);
        // Check if best child node
        // Ties are broken in favor of a) lower move delta, then b) lower distance from board center
        // The latter condition is to discourage sojourning through the limbs of non-goal triangles, where units can become trapped
        if (
          childRh < node.rh ||
          childRh == node.rh && (move.bonusDelta < node.bonusDelta ||
          move.bonusDelta == node.move.bonusDelta && (move.radialDelta < node.move.radialDelta ||
          move.radialDelta == node.move.radialDelta && (move.delta < node.move.delta ||
          move.delta == node.move.delta && (Math.random() * 4) >>> 1
        )))) {
          node.move = move;
          node.h = child.h;
          node.rh = childRh;
          node.child = child; // For debugging
        }
        // Return unit to original state
        move.source.setSubunit(unit);
        // Check for pruning
        if (node.rh <= zeta || node.win)
          break;
      }; // End of move iteration
    }
    return node;
  }

  _reduceNodeH(h, player) {
    let net = 0;
    for (let i = 0; i < 6; i++) {
      // This is substantially faster than + casting
      let cur = i == player.dir ? 1 : 0;
      net += (player.type + cur) * h[i] * (cur ? 1 : -1);
    }
    return net;
  }
}
Game.DEBUG = false;
Game.history = [];
Game.nodeHistory = [];

class Player {
  constructor(config, dir, type) {
    this.config = config;
    this.dir = dir;
    this.type = type;
    this.name = this.computer ? 'Computer' : this.human ? 'Human' : 'Disabled';
    this.lastMove = null;
    this.goal = Cubic.fromDir(dir, config.size);
    this.origin = this.goal.inverse();
    this.h = 0;
    this.units = [];
    for (let i = 0; i < config.units; i++) {
      this.units.push(new Unit(this, i));
    }
    // Pad links with dummy head and tail to simplify resorting
    this.unitHead = {h: 1e4, next: this.units[0], prev: false};
    this.unitTail = {h: -1e4, prev: this.units.slice(-1)[0], next: false};
    for (let i = 0; i < config.units; i++) {
      this.units[i].prev = this.units[i - 1] || this.unitHead
      this.units[i].next = this.units[i + 1] || this.unitTail;
    }
  }

  get computer() { return this.type == _COMPUTER };

  get human() { return this.type == _HUMAN };

  get unitClasses() {
    return [
      'unit',
      this.computer ? 'unit-computer' : 'unit-human',
      'player-' + this.dir
    ];
  }

  get victory() {
    return this.h <= this.config.h;
  };

  get shortName() {
    return 'P' + this.dir;
  }

  toString() {
    return `Player ${this.dir}`;
  }
}

class Unit {
  constructor(player, i) {
    this.player = player;
    this.id = i;
    this.h = player.goal.metric(player.origin);
    player.h += this.h;
  }

  setCell(cell) {
    let player = this.player;
    this.cell = cell;
    let oldH = this.h;
    this.cubic = cell.cubic;
    this.h = player.goal.metric(this.cubic);
    let deltaH = this.h - oldH;
    player.h += deltaH;
    // We don't actually need to keep these sorted in the current implementation,
    // but I don't think this is any less efficient than alternative means of keeping track of the lowest unit h
    if (deltaH > 0) {
      let temp = this.prev;
      while (temp.h < this.h)
        temp = temp.prev;
      if (temp != this.prev) {
        this.prev.next = this.next;
        this.next.prev = this.prev;
        this.prev = temp;
        this.next = temp.next;
        temp.next.prev = this;
        temp.next = this;
      }
    }
    else if (deltaH < 0) {
      let temp = this.next;
      while (temp.h > this.h)
        temp = temp.next;
      if (temp != this.next) {
        this.prev.next = this.next;
        this.next.prev = this.prev;
        this.next = temp;
        this.prev = temp.prev;
        temp.prev.next = this;
        temp.prev = this;
      }
    }
  }
}

class Board {
  constructor(game) {
    let config = game.config;
    let parentContainer = document.body;
    this.game = game;
    this.cells = {};
    this.clicked = null;
    this.gesture = null;
    this.targets = [];
    this.rotation = 0;

    this.points = Array(6).fill()
    .map((e, i) => [Math.sin(Math.PI / 3 * i), Math.cos(Math.PI / 3 * i)])
    .map((p) => p.map((e) => (e * config.cellRadius).toFixed(4)).join(','))
    .join(' ');

    parentContainer.querySelectorAll(':scope > .container').forEach((e) => e.remove());
    let svgArgs = {
      width: 86.6,
      height: 100,
      viewBox: '-43.3 -50 86.6 100',
      preserveAspectRatio: 'xMidYMid meet',
      class: 'board'
    };
    document.body.onkeydown = (ev) => this.processKey(ev);

    this.container = this.createElement(null, {class: 'container'}, parentContainer);
    this.svg = this.createSvgElement('svg', svgArgs, this.container);
    this.svg.addEventListener('click', (ev) => this.boardClick(ev));
    this.svg.addEventListener('touchstart', (ev) => this.processTouch(ev));
    this.svg.addEventListener('touchmove', (ev) => this.processTouch(ev));
    this.svg.addEventListener('touchend', (ev) => this.processTouch(ev));
    this.wobbleGroup = this.createSvgElement('g', {}, this.svg);
    this.rotateGroup = this.createSvgElement('g', {}, this.wobbleGroup);

    this.messageElement = this.createElement(null, {class: 'message'}, this.container);
    this.turnElement = this.createElement(null, {class: 'turn'}, this.container);
    this.optButton = this.createElement(null, {class: 'help'}, this.container);
    this.optButton.addEventListener('click', () => this.displayModal(true));

    let buttonContainer = this.createElement(null, {class: 'status'}, this.container);
    this.playerButtons = [];
    for (let i = 0; i < 6; i++) {
      let button = this.createElement(null, {}, buttonContainer);
      button.classList.add(`player-${i}`, Board.BUTTON_CLASS_MAP[config.players[i].type]);
      if (game.config.players[i].type != _DISABLED)
        button.addEventListener('click', () => this.togglePlayer(i));
      this.playerButtons.push(button);
    }

    this.modal = this.createElement(null, {class: 'modal outer'}, this.container);
    this.modal.addEventListener('click', (ev) => {
      if (ev.target == this.modal) this.displayModal(false);
    });
    let modalInner = this.createElement(null, {class: 'modal inner'}, this.modal);
    this.createElement('label', {}, modalInner, 'Board size');
    let sizeGroup = this.createElement(null, {class: 'group size'}, modalInner);
    this.createElement('label', {}, modalInner, 'Player defaults');
    let playerGroup = this.createElement(null, {class: 'group players'}, modalInner);
    let buttonGroup = this.createElement(null, {class: 'group buttons'}, modalInner);
    let saveButton = this.createElement('button', {}, buttonGroup, 'Save settings');
    let newButton = this.createElement('button', {}, buttonGroup, 'New game');
    let helpText = this.createElement(null, {class: 'helptext'}, modalInner, HELPTEXT);
    let sizeButtons = [];
    let newConfig = {size: config.size, players: config.args.players};
    Array(6).fill().forEach((_, i) => {
      let size = i + 1;
      let sizeButton = this.createElement(null, {}, sizeGroup, `<span>${size}</span>`);
      let playerButton = this.createElement(null, {class: `player-${i}`}, playerGroup);
      sizeButtons.push(sizeButton);
      if (newConfig.size == size)
        sizeButton.classList.add('selected');
      let playerStatus = newConfig.players[i];
      playerButton.classList.add(Board.BUTTON_CLASS_MAP[playerStatus]);
      sizeButton.addEventListener('click', () => {
        newConfig.size = size;
        sizeButtons.forEach((e) => e.classList.remove('selected'));
        sizeButton.classList.add('selected');
      });
      playerButton.addEventListener('click', () => {
        let playerConfig = newConfig.players.split('');
        let oldType = playerConfig[i]
        let newType = (oldType + 1) % 3;
        playerConfig[i] = newType;
        playerButton.classList.remove(Board.BUTTON_CLASS_MAP[oldType]);
        playerButton.classList.add(Board.BUTTON_CLASS_MAP[newType]);
        newConfig.players = playerConfig.join('');
      });
    });
    saveButton.addEventListener('click', () => {
      new Config(newConfig);
      this.displayModal(false);
    });
    newButton.addEventListener('click', () => {
      new Config(newConfig);
      Game.new();
    });

    // Initialize and place cells
    let boardRadius = config.size * 2;
    for (var i = -boardRadius; i < boardRadius + 1; i++) {
      for (var j = -boardRadius; j < boardRadius + 1; j++) {
        let cubic = new Cubic(i, j, -i -j);
        if (this._onBoard(cubic)) {
          let cell = new Cell(cubic);
          this.cells[cubic] = cell;
          let xFactor = config.spacing * Math.sqrt(3) / 4;
          let yFactor = config.spacing * 0.75
          let position = [
            xFactor * (cubic[1] - cubic[2]),
            yFactor * -cubic[0]
          ];
          let transform = `translate(${position.join(',')})`;
          let poly = this.createSvgElement('polygon', {transform, points: this.points}, this.rotateGroup);
          poly.cell = cell;
          cell.elem = poly;
          poly.id = 'cell_' + cubic.join('_');
          let title = this.createSvgElement('title', {}, poly);
          title.innerHTML = cubic;
          poly.addEventListener('click', () => this.click(cell));
        }
      }
    }

    // Set cell neighbors and jumps
    for (let cell of Object.values(this.cells)) {
      cell.neighbors = cell.cubic.neighborCubics().map((e) => this.cells[e]);
    }
    for (let cell of Object.values(this.cells)) {
      cell.jumps = cell.neighbors.map((e, i) => e ? e.neighbors[i] : null);
    }
  }

  togglePlayer(idx) {
    let player = this.game.config.players[idx];
    let old = player.type;
    let next = player.type = +!(old - 1) + 1; // lol
    let oldClass = Board.BUTTON_CLASS_MAP[old];
    let nextClass = Board.BUTTON_CLASS_MAP[next];
    this.playerButtons[idx].classList.remove(oldClass);
    this.playerButtons[idx].classList.add(nextClass);
    for (let unit of player.units) {
      unit.cell.elem.classList.remove('unit-' + oldClass);
      unit.cell.elem.classList.add('unit-' + nextClass);
    }
    if (this.game.turn == player && next == _COMPUTER && this.game.state != -1) {
      this.game.historyTo();
      this.game.computeMove();
    }
  }

  // User click
  click(cell) {
    // Do nothing if game paused, over, or on non-human turn
    if (this.game.state != 1 || this.game.isComputerTurn) return;

    // Move unit if valid target
    if (this.clicked && this.targets.indexOf(cell) != -1) {
      this.game.pushMove({source: this.clicked, target: cell});
    }

    // Clear clicked state regardless of whether unit moved or not
    if (this.clicked) {
      this.clicked.elem.classList.remove('clicked');
      this.clicked = null;
      this.setTargets();
      if (cell.unit && cell != this.clicked) {
        // Move unit
      }
    }
    // Otheriwse handle initial click
    else if (!this.clicked && cell.unit && cell.unit.player == this.game.turn) {
      this.setTargets(cell);
      if (this.targets.length > 0) {
        this.clicked = cell;
        cell.elem.classList.add('clicked');
      }
    }
  };

  boardClick(ev) {
    if (this.game.state == 0)
      this.game.start();
    else if (this.game.state == -1)
      Game.new()
  }

  // Highlight moves
  setTargets(cell) {
    if (!cell) {
      // De-highlight all
      this.targets = [];
      for (let cell of Object.values(this.cells)) {
        if (cell) cell.setHighlight(false);
      }
    }
    else {
      // Highlight moves
      this.targets = this.game.getMoves(cell);
      this.targets.forEach((e) => e.setHighlight(true));
    }
  };

  setCurrentPlayer(player) {
    this.playerButtons.forEach((e) => e.classList.remove('active'));
    this.playerButtons[player.dir].classList.add('active');
  }

  // "Cut out" hexagram by rejecting cubics with more than 2 coords > config.size
  _onBoard(cubic) {
    return cubic.reduce((a, e) => a + (Math.abs(e) > this.game.config.size), 0) < 2;
  }

  createElement(tag, attribs, parent, content) {
    let element = document.createElement(tag || 'div');
    this._configureElement(element, attribs, parent, content);
    return element;
  }

  createSvgElement(tag, attribs, parent) {
    let element = document.createElementNS('http://www.w3.org/2000/svg', tag);
    this._configureElement(element, attribs, parent);
    return element;
  }

  _configureElement(element, attribs, parent, content) {
    attribs = attribs || {};
    for (let [k, v] of Object.entries(attribs)) {
      element.setAttribute(k, v);
    }
    if (content) element.innerHTML = content;
    if (parent) parent.appendChild(element);
  }

  display(...messages) {
    messages = messages.map((e) => typeof e == 'function' ? e(this.game) : e);
    this.messageElement.innerText = messages.join('\n');
  }

  displayModal(display) {
    display = display != null ? display : !this.modal.classList.contains('show');
    if (display)
      this.modal.classList.add('show');
    else
      this.modal.classList.remove('show');
  }

  rotate(hextant) {
    this.rotateGroup.setAttribute('transform', `rotate(${this.rotation += hextant * 60})`);
  }

  processTouch(ev) {
    if (ev.type == 'touchstart') {
      this.gesture = new Gesture(ev, this.wobbleGroup);
    }
    else if (ev.type == 'touchmove') {
      this.gesture.add(ev);
      ev.preventDefault();
    }
    else {
      this.gesture.add(ev);
      this.gesture.compute();
      if (this.gesture.get('right')) {
        this.game.historyTo(Game.instance.moveState - 1);
      }
      else if (this.gesture.get('left')) {
        this.game.historyTo(Game.instance.moveState + 1);
      }
      else if (this.gesture.get('right', 2)) {
        this.game.historyTo(0);
      }
      else if (this.gesture.get('left', 2)) {
        this.game.historyTo();
      }
      else if (this.gesture.get('down')) {
        this.game.downloadHistory();
      }
      else if (this.gesture.get('down', 3)) {
        Game.new();
      }
      else if (this.gesture.get('delete')) {
        this.game.undo();
      }
      else if (this.gesture.get('ccw')) {
        this.rotate(-1);
      }
      else if (this.gesture.get('cw')) {
        this.rotate(1);
      }
      this.gesture = null;
    }

  }

  processKey(ev) {
    let key = ev.key.toLowerCase();
    let game = this.game;
    if (key == 'n') {
      Game.new();
    }
    else if (key == ' ') {
      if (game.state == 0)
        game.start();
      else if (game.isComputerTurn)
        game.requestPause();
    }
    else if (!game.isComputerTurn || game.state != 1) {
      if (key == 'c') {
        game.downloadCurrent();
      }
      else if (key == 'd') {
        Game.DEBUG = !Game.DEBUG;
        this.display(Locale.debug);
      }
      else if (key == 'h') {
        game.downloadHistory();
      }
      else if (key == 'r') {
        this.display(Locale.ranking);
      }
      else if (key == 's') {
        this.display(Locale.inProgress);
      }
      else if (key == '+' || key == '?') {
        // For now we will alias help to the options modal
        this.displayModal();
      }
      else if (ev.key == 'Escape') {
        this.displayModal(false);
      }
      else if (ev.key == ',') {
        this.rotate(-1);
      }
      else if (ev.key == '.') {
        this.rotate(1);
      }
      else if (ev.key == 'ArrowLeft') {
        game.historyTo(Game.instance.moveState - 1)
      }
      else if (ev.key == 'ArrowRight') {
        game.historyTo(Game.instance.moveState + 1)
      }
      else if (ev.key == 'PageDown' || ev.key == 'ArrowDown') {
        game.historyTo(0);
      }
      else if (ev.key == 'PageUp' || ev.key == 'ArrowUp') {
        game.historyTo();
      }
      else if (ev.key == 'u') {
        game.undo();
      }
      else if (Number(ev.key)) {
        new Config({size: Number(ev.key)});
      }
    }
  }
}
Board.BUTTON_CLASS_MAP = [
  'disabled',
  'computer',
  'human'
];

class Gesture {
  constructor(ev, wobbler) {
    let touches = ev.changedTouches;
    this.wobbler = wobbler;
    this.touchMap = {};
    this.count = touches.length;
    this.timeStart = ev.timeStamp;
    this.time = 0;
    this.type = null;
    for (let touch of touches) {
      let [x, y] = this._normalize(touch.pageX, touch.pageY);
      this.touchMap[touch.identifier] = {
        minX: x,
        minY: y,
        maxX: x,
        maxY: y,
        startX: x,
        startY: y,
        deltaX: 0,
        deltaY: 0,
        path: [{x, y}],
        angle: [this._angle(x, y)],
        radius: [Math.sqrt(x * x + y * y)],
      };
    }
  }

  add(ev) {
    let touches = ev.changedTouches;
    this.count = Math.max(this.count, touches.length);
    this.time = ev.timeStamp - this.timeStart;
    for (let touch of touches) {
      let entry = this.touchMap[touch.identifier];
      let [x, y] = this._normalize(touch.pageX, touch.pageY);
      let angle = this._angle(x, y);
      let radius = Math.sqrt(x * x + y * y);
      entry.path.push({x, y});
      entry.angle.push(angle);
      entry.radius.push(radius);
      Object.assign(entry, {
        minX: Math.min(entry.minX, x),
        minY: Math.min(entry.minY, y),
        maxX: Math.max(entry.maxX, x),
        maxY: Math.max(entry.maxY, y),
        endX: x,
        endY: y,
        deltaX: x - entry.startX,
        deltaY: y - entry.startY
      });
      if (touch.identifier == 0 && this.wobbler) {
        let translate = [entry.deltaX, entry.deltaY].map((e) => (e / 50).toFixed(3));
        this.wobbler.setAttribute("transform", `translate(${translate.join(',')})`);
      }
    }
    if (ev.type == 'touchend' && this.wobbler) {
      this.wobbler.setAttribute('transform', '');
    }
  }

  compute() {
    // Skip short or long touches
    if (this.time < 100 || this.time > 2000) return;

    // Compute directional swipes
    let typeMap = Object.values(this.touchMap).map((touch) => {
      // Swipe horizontal
      if (Math.abs(touch.maxY - touch.minY) < 50) {
        if (touch.deltaX < -100)
         return 'left';
        else if (touch.deltaX > 100)
         return 'right';
      }
      // Swipe vertical
      else if (Math.abs(touch.maxX - touch.minX) < 50) {
        if (touch.deltaY < -100)
          return 'up';
        else if (touch.deltaY > 100)
          return 'down';
      }
      let startAngle = touch.angle[0];
      let endAngle = touch.angle.slice(-1)[0];
      let deltaAngle = endAngle - startAngle;
      for (let i = 1; i < touch.path.length; i++) {
        let a = touch.path[i - 1], b = touch.path[i];
        if (a.x > 0 && a.y * b.y < 0) {
          let c = a.y > 0 ? 1 : -1;
          deltaAngle = (Math.PI * 2 + deltaAngle * c) * c;
          break;
        }
      }
      let meanRadius = touch.radius.reduce((a, e) => a + e) / touch.radius.length;
      let radiusCheck = meanRadius > 25 && touch.radius.reduce((a, e) => a && Math.abs(meanRadius - e) < 25, true);
      // Undo gesture - derived from copy editor's delete mark
      if (Math.abs(deltaAngle) > Math.PI * 2 && Math.abs(touch.deltaX) > 100) {
        return 'delete';
      }
      // Else check radius for proper cw or ccw arc
      if (radiusCheck) {
        if (deltaAngle > Math.PI / 3)
          return 'ccw';
        else if (deltaAngle < -Math.PI / 3)
          return 'cw';
      }
    });
    this.type = typeMap.reduce((a, e) => a == e ? a : null);
  }

  get(type, num) { return this.count == (num || 1) && this.type == type; }

  _normalize(x, y) {
    let width = window.innerWidth;
    let height = window.innerHeight;
    let scale, offsetX, offsetY;
    if (width < height) {
      scale = 200 / width;
      offsetX = 100;
      offsetY = 100 * height / width;
    }
    else {
      scale = 200 / height;
      offsetX = 100 * width / height;
      offsetY = 100;
    }
    return [
      x * scale - offsetX,
      y * scale - offsetY
    ];
  }

  _angle(x, y) {
    let max = Math.max(Math.abs(x), Math.abs(y));
    x = x / max;
    y = y / max;
    let a = Math.acos(x / Math.sqrt(x * x + y * y));
    if (y > 0) a = Math.PI * 2 - a;
    return a;
  }
}

// Cubic (coordinates)

class Cubic extends Array {
  static fromDir(dir, metric) {
    return new Cubic(...Cubic.DIR_TO_CUBIC[dir]).mult(metric * 2);
  }
  static dirTuple(dir) {
    return [dir % 3, (dir % 2) * -2 + 1];
  }

  constructor(u, v, w) {
    super();
    u = u != null ? u : -v - w;
    v = v != null ? v : -w - u;
    w = w != null ? w : -u - v;
    this.push(u);
    this.push(v);
    this.push(w);
  }

  dirCubics(dir, steps) {
    let [d, s] = Cubic.dirTuple(dir);
    let a = (d + 1) % 3;
    let b = (d + 2) % 3;
    let D = this[d] + steps * s;
    let results = [];
    for (let i = 0; i <= steps; i++) {
      let coords = new Array(3);
      coords[d] = D;
      coords[a] = this[a] - i * s;
      coords[b] = this[b] - (steps - i) * s;
      results.push(new Cubic(...coords));
    }
    return results;
  }

  neighborCubics() {
    return Cubic.NEIGHBOR_OFFSETS.map((e) => this.add(new Cubic(...e)));
  }

  add(cubic) { return new Cubic(...this.map((e, i) => e + cubic[i])); }

  mult(scalar) { return new Cubic(...this.map((e) => e * scalar)); }

  map(f) { return new Cubic(...super.map(f)); }

  inverse() { return this.map((e) => -e); }

  metric(cubic) {
    return (
      Math.abs(this[0] - cubic[0]) + Math.abs(this[1] - cubic[1]) + Math.abs(this[2] - cubic[2])
    ) >>> 1;
  }

  metricFromOrigin() {
    return Math.abs(this[0]) + Math.abs(this[1]) + Math.abs(this[2]);
  }

  toString() { return `(${this.join(',')})`; }
}
Cubic.NEIGHBOR_OFFSETS = [
  [0, 1, -1],
  [1, 0, -1],
  [1, -1, 0],
  [0, -1, 1],
  [-1, 0, 1],
  [-1, 1, 0]
];
Cubic.DIR_TO_CUBIC = [
  [1, -0.5, -0.5],
  [0.5, -1, 0.5],
  [-0.5, -0.5, 1],
  [-1, 0.5, 0.5],
  [-0.5, 1, -0.5],
  [0.5, 0.5, -1]
];

// Cell

class Cell {
  constructor(cubic) {
    this.cubic = cubic
    this.unit = null;
    this.subunit = null;
    this.goalFor = null;
    this.highlight = false;
  }

  setUnit(unit, fwd) {
    let otherCell = unit.cell;
    let otherUnit = this.unit;
    if (otherCell) {
      otherCell.elem.setAttribute('class', '');
      if (otherUnit) {
        otherUnit.cell.elem.setAttribute('class', '');
        otherCell.elem.classList.add(...otherUnit.player.unitClasses);
        otherCell.unit = otherUnit;
        otherCell.subunit = otherUnit;
        this.subunit.setCell(otherCell);
      }
      else {
        otherCell.unit = null;
        otherCell.subunit = null;
      }
    }
    this.unit = unit;
    this.subunit = unit;
    unit.setCell(this);
    this.elem.classList.add(...unit.player.unitClasses);
    if (fwd) {
      unit.player.units.forEach((e) => e.cell.elem.classList.remove('last-move'));
      this.elem.classList.add('last-move');
    }
  }

  setSubunit(unit) {
    if (this.subunit) {
      unit.cell.subunit = this.subunit;
      this.subunit.setCell(unit.cell);
    }
    else {
      unit.cell.subunit = null;
    }
    this.subunit = unit;
    unit.setCell(this);
  }

  setHighlight(val) {
    this.highlight = val;
    if (val)
      this.elem.classList.add('highlight');
    else
      this.elem.classList.remove('highlight');
  }

  toString() {
    var player = this.unit ? this.unit.player.name : 'none';
    return this.cubic.toString() + player;
  }
}

</script>
</head>
  <body>
  <div class="hidden">
    <div id="helptext">
      <table>
        <tr class="head">
          <td>Command</td>
          <td>Key</td>
          <td>Touch</td>
        </tr>
        <tr>
          <td>New game</td>
          <td>N</td>
          <td><svg class="icon" style="transform: rotate(180deg)"><use xlink:href="#linear-3"/></svg></td>
        </tr>
        <tr>
          <td>Undo move</td>
          <td>U</td>
          <td><svg class="icon" style="transform: scaleX(-1)"><use xlink:href="#delete"/></svg></td>
        </tr>
        <tr>
          <td>Prev pos</td>
          <td><svg class="icon" style="transform: rotate(-90deg)"><use xlink:href="#linear-1"/></svg></td>
          <td><svg class="icon" style="transform: rotate(90deg)"><use xlink:href="#linear-1"/></svg></td>
        </tr>
        <tr>
          <td>Next pos</td>
          <td><svg class="icon" style="transform: rotate(90deg)"><use xlink:href="#linear-1"/></svg></td>
          <td><svg class="icon" style="transform: rotate(-90deg)"><use xlink:href="#linear-1"/></svg></td>
        </tr>
        <tr>
          <td>First pos</td>
          <td><svg class="icon" style="transform: rotate(-180deg)"><use xlink:href="#linear-1"/></svg></td>
          <td><svg class="icon" style="transform: rotate(90deg)"><use xlink:href="#linear-2"/></svg></td>
        </tr>
        <tr>
          <td>Current pos</td>
          <td><svg class="icon"><use xlink:href="#linear-1"/></td>
          <td><svg class="icon" style="transform: rotate(-90deg)"><use xlink:href="#linear-2"/></svg></td>
        </tr>
        <tr>
          <td>Rotate CCW</td>
          <td>,</td>
          <td><svg class="icon" style="transform: scaleX(-1)"><use xlink:href="#cw"/></svg></td>
        </tr>
        <tr>
          <td>Rotate CW</td>
          <td>.</td>
          <td><svg class="icon"><use xlink:href="#cw"/></svg></td>
        </tr>
      </table>
    </div>
    <svg xmlns="http://www.w3.org/2000/svg">
      <symbol id="cw" viewBox="0 0 30 30">
        <path d="M22.071,7.929L19.95,10.05c2.733,2.734,2.733,7.166,0,9.9c-2.734,2.733-7.166,2.733-9.9,0
  c-2.733-2.734-2.734-7.166,0-9.9l2.121,2.121L14.5,3.479L5.808,5.808l2.121,2.121c-3.905,3.906-3.905,10.237,0,14.143
  c3.906,3.905,10.236,3.905,14.143,0C25.977,18.166,25.977,11.834,22.071,7.929z"/>
      </symbol>
      <symbol id="delete" viewBox="0 0 30 30">
        <path d="M22.498,22.605c-1.457,0-2.859-0.218-4.193-0.602c0.703-0.524,1.379-1.082,1.998-1.701c2.93-2.929,2.93-7.678,0-10.606
  c-2.928-2.93-7.677-2.93-10.606,0c-2.929,2.929-2.929,7.678,0,10.606c0.618,0.619,1.295,1.177,1.997,1.701
  c-1.332,0.384-2.735,0.602-4.191,0.602h-3v3h3c2.678,0,5.211-0.597,7.498-1.64c2.287,1.043,4.82,1.64,7.498,1.64h3v-3H22.498z
   M15,20.602c-1.166-0.668-2.24-1.477-3.183-2.42c-1.757-1.757-1.757-4.606,0-6.364s4.606-1.758,6.364,0s1.758,4.607,0,6.364
  C17.238,19.125,16.164,19.934,15,20.602z"/>
      </symbol>
      <symbol id="linear-1" viewBox="0 0 30 30">
        <polygon points="15,5.103 10.5,12.897 13.5,12.897 13.5,24.897 16.5,24.897 16.5,12.897 19.5,12.897"/>
      </symbol>
      <symbol id="linear-2" viewBox="0 0 30 30">
        <polygon points="10.5,5.103 6,12.898 9,12.898 9,24.896 12,24.896 12,12.898 15,12.898"/>
        <polygon points="19.5,5.102 15,12.896 18,12.896 18,24.898 21,24.898 21,12.896 24,12.896"/>
      </symbol>
      <symbol id="linear-3" viewBox="0 0 30 30">
        <polygon points="6,5.103 1.5,12.897 4.5,12.897 4.5,24.896 7.5,24.896 7.5,12.897 10.5,12.897"/>
        <polygon points="15,5.102 10.5,12.896 13.5,12.896 13.5,24.898 16.5,24.898 16.5,12.896 19.5,12.896"/>
        <polygon points="24,5.102 19.5,12.897 22.5,12.897 22.5,24.898 25.5,24.898 25.5,12.897 28.5,12.897"/>
      </symbol>
    </svg>
  </div>
</body>
</html>